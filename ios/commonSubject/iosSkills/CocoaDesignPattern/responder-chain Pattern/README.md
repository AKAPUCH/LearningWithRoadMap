# responder-chain 패턴
## 참고문헌
- [kodeco design patterns](https://www.kodeco.com/books/design-patterns-by-tutorials/v3.0/chapters/22-chain-of-responsibility-pattern)
## 구조
![rcp](https://user-images.githubusercontent.com/116094622/236684864-78d7259e-fc58-4044-a5a2-495bce0d3bce.png)
- 단독으로 적용되기 보다는 MVC 같은 디자인 패턴에 곁들여 주로 사용됩니다.
- 로직을 통한 이벤트가 발생하는 클라이언트 객체, 구체적인 로직이 구현되어 있는 여러 개의 핸들러, 핸들러의 구현 사항이 정의되어 있는 프로토콜로 이루어져 있습니다.
- 위 그림처럼 클라이언트 객체는 프로토콜을 준수한 첫번째 핸들러 객체만 알고 있으며, 핸들러 객체 내부 구현을 통해 다른 핸들러로 연결되어 있습니다.(responder-chain)
  
## 객체 별 특징

### 핸들러 프로토콜
- 핸들러가 필수적으로 갖춰야 할 요소들을 정의해줍니다.
- property : next
  - 핸들러 프로토콜 타입으로 선언한 속성입니다.
  - 현재 핸들러 다음에 적용되는 핸들러를 의미합니다.
- 로직 메서드

### 상세 구현 핸들러
- 핸들러 프로토콜 타입을 준수하는 객체입니다.
- next 프로퍼티에 다음 핸들러 할당
- 값에 적용될 로직 메서드 구현. `guard let` 바인딩을 통해 validation 실패시 다음 handler로 넘깁니다.
- 마지막 핸들러의 next 프로퍼티는 nil입니다.

### 클라이언트 객체
- 핸들러와 직접 상호작용합니다.
- 컨트롤러에서는 클라이언트 객체를 프로퍼티로 가져와 원하는 시점에 특정 값에 대한 로직의 결과를 얻습니다.
- 프로퍼티
  - 핸들러 프로토콜 타입의 객체
  - 로직이 적용될 값. 속성감시자를 통해 변화시 핸들러를 계속 설정해줍니다.
- 메서드
  - 책임-연쇄 로직 구현 메서드 : 현재 값의 핸들러를 설정함과 동시에 현재 핸들러 `next` 핸들러도 지정해줍니다.
  - 핸들러의 상세구현 메서드를 호출하는 메서드 : 최종 실패시 로직이 구현되어 있습니다.
  
## 사용하는 용도?
- if ~ else 문으로 담기에는 조건 분기가 많아 controller가 너무 복잡해지고, 추상화를 통해 실제 로직을 숨길 때 사용하게 됩니다.
  - 자판기
  - AES와 같은 암호 복호화
  
